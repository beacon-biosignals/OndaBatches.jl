<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · OndaBatches</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>OndaBatches</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Labeled-signals"><span>Labeled signals</span></a></li><li><a class="tocitem" href="#Batch-sampling"><span>Batch sampling</span></a></li><li><a class="tocitem" href="#Batch-materialization"><span>Batch materialization</span></a></li><li><a class="tocitem" href="#Batching-service"><span>Batching service</span></a></li><li><a class="tocitem" href="#Internal-utilities"><span>Internal utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="Labeled-signals"><a class="docs-heading-anchor" href="#Labeled-signals">Labeled signals</a><a id="Labeled-signals-1"></a><a class="docs-heading-anchor-permalink" href="#Labeled-signals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.LabeledSignalV2" href="#OndaBatches.LabeledSignalV2"><code>OndaBatches.LabeledSignalV2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@version LabeledSignalV2 &gt; SignalV2 begin
    label_span::TimeSpan
    labels::Union{Samples,SignalV2}
end</code></pre><p>Legolas.jl record type that represents one Onda signal with associated labels.  Labels must be dense and contiguous, and are represented as Onda.Samples or an Onda.Signal that refers to Onda.Samples serialized as LPCM. <code>label_span</code> corresponds to the time span (relative to the recording) spanned by the <code>labels</code>.</p><p>Note that the signal <code>span</code> and labels&#39; <code>label_span</code> are both relative to the start of the <em>recording</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.sub_label_span" href="#OndaBatches.sub_label_span"><code>OndaBatches.sub_label_span</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sub_label_span(labeled_signal, new_label_span)</code></pre><p>Select a sub-span of labeled signals <code>labeled_signal</code> (with schema <code>&quot;labeled.signal@2&quot;</code>), returning a new labeled signal with updated <code>labels</code> and <code>label_span</code>.</p><p>The <code>new_label_span</code> should be relative to the start of the recording (like the signal&#39;s <code>span</code> and the current <code>label_span</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L219-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.label_signals" href="#OndaBatches.label_signals"><code>OndaBatches.label_signals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">label_signals(signals, annotations;
                groups=:recording,
                labels_column,
                epoch,
                encoding,
                roundto=nothing)</code></pre><p>Create a &quot;labeled signals&quot; table from a signals table and a table of annotations containing labels.</p><p>Annotations will be passed to <a href="#OndaBatches.labels_to_samples_table"><code>labels_to_samples_table</code></a>, as well as  kwargs.  <code>labels_to_samples_table</code> requires these keyword arguments:</p><ul><li><code>groups</code>: the column to group over, defaults to <code>:recording</code>.</li><li><code>labels_column</code>: the column in the annotations table containing the labels.</li><li><code>epoch</code>: the sampling period of the labels.</li><li><code>encoding::Dict</code>: the label -&gt; <code>UInt8</code> mapping to use for encoding the labels.</li><li><code>roundto</code>: controls rounding of &quot;shaggy spans&quot;, defaults to <code>nothing</code> for no rounding.</li></ul><p>Annotations must be</p><ul><li>contiguous and non-overlapping (withing <code>groups</code>)</li><li>regularly sampled, with spans an even integer multiple of the <code>epoch</code> kwarg.</li></ul><p>Returns a <a href="#OndaBatches.LabeledSignalV2"><code>LabeledSignalV2</code></a> table (e.g., with schema <code>&quot;labeled.signal@2&quot;</code>), with labels in <code>:labels</code> and the signal spans occupied by these labels in <code>:label_span</code>.  Like the signal <code>:span</code>, the <code>:label_span</code> is relative to the start of the <em>recording</em>, not necessarily to the start of the data represented by the <em>signal</em>.</p><p>If any label span is not entirely contained within the corresponding signal span, this will throw an ArgumentError.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L158-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.load_labeled_signal" href="#OndaBatches.load_labeled_signal"><code>OndaBatches.load_labeled_signal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function load_labeled_signal(labeled_signal, samples_eltype::Type=Float64)</code></pre><p>Load signal data as <code>Onda.Samples</code> from a labeled segment of an <code>Onda.SignalV2</code> (i.e., a <a href="#OndaBatches.LabeledSignalV2"><code>LabeledSignalV2</code></a> or row with schema <code>&quot;labeled.signal@2&quot;</code>), and returns the portion of the samples data corresponding to <code>labeled_signal.label_span</code>, along with the corresponding labels (as another <code>Onda.Samples</code> object).</p><p>If possible, this will only retrieve the bytes corresponding to <code>labeled_signal.label_span</code>.</p><p>The <code>eltype</code> of the returned <code>Samples</code> is <code>samples_eltype</code>, which defaults to <code>Float64</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The handling of samples <code>eltype</code> is different than <code>Onda.load</code>, for which the <code>eltype</code> depends on the resolution/offset specified in the samples info: when they are 1/0 respectively, the underlying encoded data is <em>always</em> returned exactly as-is, even if the type differs from the requested <code>eltype</code>.  This allows for some optimizations in such cases, but is a potential footgun when a particular <code>eltype</code> is actually required.  We work around this inconsistency here by always allocating a <em>new</em> array with the requested <code>eltype</code> to hold the decoded samples.</p></div></div><p>Returns a <code>samples, labels</code> tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L67-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.store_labels" href="#OndaBatches.store_labels"><code>OndaBatches.store_labels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">store_labels(labeled_signals, root; format=&quot;lpcm&quot;)</code></pre><p>Store labels to <code>root</code>, replacing the <code>Onda.Samples</code> in the <code>labels</code> column of <code>labeled_signals</code> with <code>Onda.Signal</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L33-L38">source</a></section><section><div><pre><code class="nohighlight hljs">store_labels(labeled_signal::LabeledSignalV2, root; format=&quot;lpcm&quot;)</code></pre><p>Store a single set of labels to <code>root</code>, replacing the <code>Onda.Samples</code> in the <code>labels</code> column of <code>labeled_signals</code> with <code>Onda.SignalV2</code>s.  A single updated <code>LabeledSignalV2</code> row is returned.</p><p>The filepath of the stored labels&#39; Signal is the basename of <code>labeled_signal.file_path</code> with <code>&quot;labels_&quot;</code> prepended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L50-L59">source</a></section></article><h2 id="Batch-sampling"><a class="docs-heading-anchor" href="#Batch-sampling">Batch sampling</a><a id="Batch-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.BatchItemV2" href="#OndaBatches.BatchItemV2"><code>OndaBatches.BatchItemV2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@version BatchItemV2{T} &gt; LabeledSignalV2 begin
    batch_channels::T
end</code></pre><p>Legolas record type representing a single batch item.  Fields are inherited from <a href="#OndaBatches.LabeledSignalV2"><code>LabeledSignalV2 &gt; SignalV2</code></a>, and an additional <code>batch_channels</code> field gives a channel selector for this batch.  A &quot;channel selector&quot; is anything that can be used as a channel index for <code>Onda.Samples</code>, or <code>missing</code> (in which case, all channels will be used in the order they occur in the <code>Samples</code>).</p><p>Columns include:</p><ul><li>columns from <code>Onda.SignalV2</code> (everything required to <code>Onda.load</code> the segment)</li><li><code>labels</code> and <code>label_span</code> from <code>LabeledSignalV2</code></li><li><code>batch_channels</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/materialize_batch.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.RandomBatches" href="#OndaBatches.RandomBatches"><code>OndaBatches.RandomBatches</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomBatches</code></pre><p>An iterator of pseudo-randomly sampled batches derived from a table of densely labeled signals (a <a href="#OndaBatches.LabeledSignalV2"><code>labeled.signal@2</code></a> table). Batches consist of <code>batch_size</code> &quot;batch items&quot;. A single batch item consists of <code>batch_duration * label_sample_rate</code> labels, and <code>batch_duration * signal_sample_rate</code> samples of multichannel data.</p><p>Batch items are sampled according to the following procedure:</p><ol><li>A single labeled signal is sampled (optionally with weights)</li><li>A single label from that signal is sampled (optionally with weights)</li><li>One or more channels is selected, optionally randomly.</li></ol><p>Each batch item is sampled independently, and in particular different batch items in a given batch can have different channels included (although the same number of them, <code>n_channels</code>).</p><p>The functions <a href="#OndaBatches.iterate_batch_item"><code>iterate_batch_item</code></a> and <a href="#OndaBatches.iterate_batch"><code>iterate_batch</code></a> sample a single batch item and a full batch, respectively.</p><p><strong>Fields</strong></p><ul><li><code>labeled_signals::DataFrame</code>: the table of labeled signals that batches are sampled from.</li><li><code>signal_weights::AbstractWeights</code>: weights for individual signals (unweighted by default).  May be <code>nothing</code> duration construction, in which case unit  weights are created.</li><li><code>label_weights::Vector{AbstractWeights}</code>: weights for individual labels of each labeled signal (unweighted by default).  May be <code>nothing</code> during construction, in which case unit weights will be created for each labeled signal.</li><li><code>n_channels::Union{Nothing,Int}</code>: the number of channels each batch item should have; this many channels are sampled without replacement, unless  <code>n_channels === nothing</code> in which case all channels are included.</li><li><code>batch_size::Int</code>: the number of items that make one complete batch</li><li><code>batch_duration::TimePeriod</code>: the duration of the window for a single batch.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/iterate_batch.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.iterate_batch_item" href="#OndaBatches.iterate_batch_item"><code>OndaBatches.iterate_batch_item</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterate_batch_item(batches::RandomBatches, rng)</code></pre><p>Yields a single &quot;batch item&quot;.  See documentation for <a href="#OndaBatches.RandomBatches"><code>RandomBatches</code></a> for the details on the sampling scheme.</p><p>Individual batch items are rows of a batch table with schema <a href="#OndaBatches.BatchItemV2"><code>&quot;batch-item@2&quot;</code></a>, and are consumed by <a href="#OndaBatches.materialize_batch_item"><code>materialize_batch_item</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/iterate_batch.jl#L95-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.iterate_batch" href="#OndaBatches.iterate_batch"><code>OndaBatches.iterate_batch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterate_batch(batches::Batches, rng)</code></pre><p>Return a &quot;batch listing&quot; that can be materialized into model training/evaluation input.</p><p>A batch is a table that has one row per batch item, and follows the <a href="#OndaBatches.BatchItemV2"><code>&quot;batch-item@2&quot;</code></a> schema.</p><p>This is consumed by a <a href="#OndaBatches.materialize_batch"><code>materialize_batch</code></a> function that can be run on a remote worker, so this sends just the minimum of information necessary to load the batch signal data, the stage labels, and the spans that say how they line up.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/iterate_batch.jl#L71-L84">source</a></section></article><h2 id="Batch-materialization"><a class="docs-heading-anchor" href="#Batch-materialization">Batch materialization</a><a id="Batch-materialization-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-materialization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.materialize_batch_item" href="#OndaBatches.materialize_batch_item"><code>OndaBatches.materialize_batch_item</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">materialize_batch_item(batch_item, samples_eltype::Type=Float64)</code></pre><p>Load the signal data for a single <a href="#OndaBatches.BatchItemV2"><code>BatchItemV2</code></a>, selecting only the channels specified in the <code>batch_channels</code> field (using all channels if the field is <code>missing</code>).</p><p>Returns a <code>signal_data, label_data</code> tuple, which is the contents of the <code>data</code> field of the signals and labels <code>Samples</code> objects returned by <code>[load_labeled_signal</code>](@ref), after the signals data by <code>batch_channels</code>.</p><p>The eltype of <code>signal_data</code> will be <code>samples_eltype</code>; the eltype of <code>label_data</code> is whatever is returned by <a href="#OndaBatches.get_labels"><code>get_labels</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/materialize_batch.jl#L26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.materialize_batch" href="#OndaBatches.materialize_batch"><code>OndaBatches.materialize_batch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">materialize_batch(batch, samples_eltype::Type=Float64)</code></pre><p>Materialize an entire batch, which is a table of <a href="#OndaBatches.BatchItemV2"><code>BatchItemV2</code></a> rows.  Each row is materialized concurrently by <a href="#OndaBatches.materialize_batch_item"><code>materialize_batch_item</code></a>, and the resulting signals and labels arrays are concatenated on dimension <code>ndims(x) + 1</code> respectively.</p><p>Returns a <code>signal_data, label_data</code> tuple.  The dimensionality of these arrays depends on the dimensionality of the results of <a href="#OndaBatches.materialize_batch_item"><code>materialize_batch_item</code></a>, but will in general be <code>ndims(x) + 1</code>.</p><p>The eltype of <code>signal_data</code> will be <code>samples_eltype</code>; the eltype of <code>label_data</code> is whatever is returned by <a href="#OndaBatches.get_labels"><code>get_labels</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/materialize_batch.jl#L57-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.get_channel_data" href="#OndaBatches.get_channel_data"><code>OndaBatches.get_channel_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_channel_data(samples, channels)</code></pre><p>Get the data associated with the specified channels.  Default fallback simply calls <code>samples[channels, :].data</code>.  But custom channel selectors can be used to implement more exotic featurization schemes, (see tests for examples).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/materialize_batch.jl#L48-L54">source</a></section></article><h2 id="Batching-service"><a class="docs-heading-anchor" href="#Batching-service">Batching service</a><a id="Batching-service-1"></a><a class="docs-heading-anchor-permalink" href="#Batching-service" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.Batcher" href="#OndaBatches.Batcher"><code>OndaBatches.Batcher</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct that provides control of batching process on one or more remote workers.  This struct keeps track of</p><ul><li><code>manager::Int</code> the PID where <code>start_batching</code> will be called.</li><li><code>workers</code> an <code>AbstractWorkerPool</code> for the worker process(es).</li><li><code>channel::RemoteChannel</code> the channel that batches are loaded into.</li><li><code>status::Future</code> the return value of the <code>start_batching</code> function as a Future; see <a href="#OndaBatches.get_status"><code>get_status</code></a> for a convenient accessor.</li><li><code>batches</code> the iterator of batches that will be materialized; only requirement is that <a href="#OndaBatches.iterate_batch"><code>iterate_batch</code></a> be defined; see <a href="#OndaBatches.RandomBatches"><code>RandomBatches</code></a> for an example</li><li><code>state::Any</code> batcher state (passed to <a href="#OndaBatches.iterate_batch"><code>iterate_batch</code></a>, updated with each new batch that&#39;s yielded by the batcher.</li><li><code>buffer::Int</code> the size of the batch buffer to keep locally (e.g., the capacity  of <code>channel</code>).</li></ul><p>Use <a href="#OndaBatches.start!"><code>start!</code></a> to start the batching service, <a href="#OndaBatches.stop!"><code>stop!</code></a> to stop it, and <a href="#OndaBatches.get_status"><code>get_status</code></a> to check the status.</p><p>Once the batcher is started, the sequence of materialized batches (the output of <a href="#OndaBatches.materialize_batch"><code>materialize_batch</code></a>) and corresponding batcher states can be retrieved by <a href="#Base.take!-Tuple{Batcher, Any}"><code>take!</code></a>.</p><p><strong>Architecture</strong></p><p>A <code>Batcher</code> is meant to run in an architecture where remote workers are created with a Distributed.jl cluster manager.  We use the following terminology to describe the roles these different processes play:</p><ul><li><p>&quot;Batch worker&quot;: one or more processes that are used to actually load batches (via <a href="#OndaBatches.materialize_batch"><code>materialize_batch</code></a>)</p></li><li><p>&quot;Batch manager&quot;: the process which coordinates the loading of batches, ensuring consistent iteration order, distributing work to the batch workers, and populating the output channel.  <a href="#OndaBatches.start_batching"><code>start_batching</code></a> runs on this process.</p></li><li><p>&quot;Client&quot;: the process which is consuming batches via <code>take!(::Batcher, state)</code> (which OndaBatches.jl is generally agnostic about and does not manage)</p></li><li><p>&quot;Manager&quot;: the process on which the <code>Batcher</code> is initially created, and holds the reference for the worker pool (for multi-worker batching).</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We try hard to make <code>Batcher</code>s relocatable to other processes (e.g., serializing to the Client after initialization on the Manager).  However, since a new <code>RemoteChannel</code> is created each time the batcher is started (including when the desired state does not match the <code>Batcher</code>&#39;s current state), some care needs to be taken if it matters where that channel is hosted (although this behavior may change in the future).</p><p>Also note that while a running (i.e. <code>start!</code>ed) <code>Batcher</code> can be relocated to another process, the <code>status</code> and <code>channel</code> fields are not guaranteed to stay in sync on the two copies.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L235-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.Batcher-Tuple{Int64, Distributed.AbstractWorkerPool, Any}" href="#OndaBatches.Batcher-Tuple{Int64, Distributed.AbstractWorkerPool, Any}"><code>OndaBatches.Batcher</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Batcher([manager::Int,] workers::Vector{Int}, batches; start=true, state=nothing, buffer=2 * length(workers) + 1)
Batcher(manager::Int, workers::AbstractWorkerPool, batches; start=true, state=nothing, buffer=2 * length(workers) + 1)</code></pre><p>Construct a new <a href="#OndaBatches.Batcher"><code>Batcher</code></a>, using worker IDs, batches, and initial state. The batcher&#39;s channel and status will be initialized.</p><p>The <code>workers</code> may be specified as an <code>AbstractWorkerPool</code> or a vector of PIDs (in which case a <code>WorkerPool</code> will be constructed).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If workers are supplied as an <code>AbstractWorkerPool</code>, it is assumed that <em>all</em> workers managed by the pool are available for loading batches.  Whenever the batcher is stopped, the worker pool is reset, and all managed workers are returned to the channel of available workers.</p></div></div><p>See <a href="#OndaBatches.RandomBatches"><code>RandomBatches</code></a> for an example of creation of <code>batches</code>.</p><p>The initial <code>state</code> is the state that is used by <a href="#OndaBatches.iterate_batch"><code>iterate_batch</code></a>, e.g., the RNG used by <a href="#OndaBatches.RandomBatches"><code>RandomBatches</code></a>.</p><p>If <code>start=true</code>, batching is <a href="#OndaBatches.start!"><code>start!</code></a>ed. The <code>state</code> keyword argument must be supplied in this case to provide an initial state.</p><p>The <code>buffer</code> controls the capacity of the batch channel; a value greater than or equal to the number of workers is recommended so that batch loading workers do not block waiting for batches to be taken off the channel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L316-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.take!-Tuple{Batcher, Any}" href="#Base.take!-Tuple{Batcher, Any}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.take!(batcher::Batcher, state)</code></pre><p>Take one batch + state pair from the batcher, starting at the specified state. If the requested state does not match the batcher&#39;s current state, then the batching process will be restarted with the new state.  If the batcher is not running (as indicated by <a href="#OndaBatches.get_status"><code>get_status</code></a>), it will be started with <a href="#OndaBatches.start!"><code>start!</code></a>.</p><p>If an error has occurred on any of the batch loading workers, the next call to <code>take!</code> will immediately throw the wrapped <code>RemoteException</code>, even if there are still good batches on the channel.</p><p>Returns an <code>(x, y), state</code> tuple, where <code>x</code> is the batch signal data, <code>y</code> is the label data (see <a href="#OndaBatches.materialize_batch"><code>materialize_batch</code></a>), and <code>state</code> is the next batch iterator state.</p><p>Runs on the Client.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L476-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.start!" href="#OndaBatches.start!"><code>OndaBatches.start!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">start!(batcher::Batcher, state)</code></pre><p>Start the remote process that loads batches into the batcher&#39;s channel.  A new channel is created since the old one cannot always be re-used.</p><p>This invokes <a href="#OndaBatches.start_batching"><code>start_batching</code></a> on <code>batcher.manager</code> with <code>remotecall</code>.</p><p>The (modified) batcher is returned.</p><p>If the batcher is already running (as indicated by <a href="#OndaBatches.get_status"><code>get_status == :running</code></a>), a warning is raised and the batcher is returned.</p><p>Runs on the Client.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L387-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.stop!" href="#OndaBatches.stop!"><code>OndaBatches.stop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stop!(batcher::Batcher)</code></pre><p>Close <code>batcher.channel</code> to stop the remote batching.  This blocks on <code>fetch(batcher.status)</code> to wait for channel closure.  If an error is thrown on the remote worker that is not caught, it will be rethrown here.</p><p>The batcher is returned.</p><p>Runs on the Client.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L450-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.get_status" href="#OndaBatches.get_status"><code>OndaBatches.get_status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_status(batcher::Batcher)</code></pre><p>Check the status of a remote batcher.</p><p>Possible return values are</p><ul><li><code>:stopped</code>: the batcher was created but not started</li><li><code>:running</code>: the batching loop is still running</li><li><code>:closed</code>: the batch channel was closed and the batch loop has terminated</li><li><code>:done</code>: the infinite loop in <a href="#OndaBatches.start_batching"><code>start_batching</code></a> has terminated without  error (not expected)</li><li>a <code>RemoteException</code> that wraps an error thrown by <code>start_batching</code> on the batch manager (which may further wrap an exception thrown on a batch worker</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L360-L373">source</a></section></article><h2 id="Internal-utilities"><a class="docs-heading-anchor" href="#Internal-utilities">Internal utilities</a><a id="Internal-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-utilities" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>None of the following are meant to be called by users, are not part of the API for semantic versioning purposes, and can change at any time.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.labels_to_samples_table" href="#OndaBatches.labels_to_samples_table"><code>OndaBatches.labels_to_samples_table</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">labels_to_samples_table(labels::AbstractDataFrame; labels_column,
                        groups=:recording, epoch, kwargs...)</code></pre><p>Convert annotations table into a table of labels as Samples.  This groups by <code>groups</code> (defaults to <code>:recording</code>), and then applies <a href="#OndaBatches.int_encode_labels"><code>int_encode_labels</code></a> to the <code>labels_column</code> and <code>:span</code> columns from each group, and converts the resulting <code>UInt8</code> labels to <code>Onda.Samples</code> via <a href="#OndaBatches.labels_to_samples"><code>labels_to_samples</code></a>.  The sampling rate for the resulting labels is <code>1 / epoch</code>.  The samples are returned in the <code>:labels</code> column.</p><p>Along with <code>epoch</code>, additional kwargs are forwarded to <a href="#OndaBatches.int_encode_labels"><code>int_encode_labels</code></a>:</p><ul><li><code>encoding::Dict</code> the label -&gt; <code>UInt8</code> mapping to use for encoding</li><li><code>roundto</code> controls rounding of &quot;shaggy spans&quot; (defaults to <code>nothing</code> for no rounding)</li></ul><p>The <code>span</code> corresponding to these labels is determined by <a href="#OndaBatches.floor_containing"><code>floor_containing</code></a> and returned in the <code>:label_span</code> column.</p><p>A <code>DataFrame</code> is returned with the <code>:labels</code> and <code>:label_span</code> per group, as well as the <code>groups</code> variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L425-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.labels_to_samples" href="#OndaBatches.labels_to_samples"><code>OndaBatches.labels_to_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">labels_to_samples(labels::AbstractVector{UInt8}; epoch)
labels_to_samples(; epoch)</code></pre><p>Convert a vector of UInt8 stage labels sampled evenly at intervals of <code>epoch</code> into <code>Onda.Samples</code> with samples rate of <code>1/epoch</code>.</p><p>The kwarg only form returns a closure that captures the <code>epoch</code>.</p><p>The returned samples have samples info:</p><pre><code class="nohighlight hljs">SamplesInfoV2(; sensor_type=&quot;label&quot;,
              channels=[&quot;label&quot;],
              sample_unit=&quot;label&quot;,
              sample_resolution_in_unit=1,
              sample_offset_in_unit=0,
              sample_type=UInt8,
              sample_rate=Second(1) / epoch)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L390-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.get_labels" href="#OndaBatches.get_labels"><code>OndaBatches.get_labels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_labels(labels::Samples, span)
get_labels(labels::SignalV2, span)</code></pre><p>Return labels as Samples, deserializing with <code>Onda.load</code> if necessary.  <code>span</code> is the span <em>relative to the start of the recording</em> that should be loaded.</p><p>This function is meant for internal use only; users should instead use <code>load_labeled_signal</code> and <code>sub_label_span</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L137-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.int_encode_labels" href="#OndaBatches.int_encode_labels"><code>OndaBatches.int_encode_labels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">int_encode_labels(stages, spans; epoch, encoding::Dict,
                  roundto=nothing)
int_encode_labels(; epoch, encoding, roundto)</code></pre><p>Return a <code>Vector{UInt8}</code> of stage labels, using <code>encoding</code> to look up each stage label in <code>stages</code>, sampled evenly at intervals of <code>epoch</code>.  <code>spans</code> are expanded into non-overlapping, contiguous spans of duration <code>epoch</code>; <code>spans</code> must be contiguous and with durations evenly divisible by <code>epoch</code>, except for the final span which will be truncated.  <code>spans</code> durations will be rounded to the nearest <code>roundto</code> (can be a <code>TimePeriod</code> subtype or instance, such as <code>Millisecond(100)</code>, or <code>nothing</code>) before division into epochs to accommodate minor errors in stage label durations; if <code>roundto=nothing</code> (the default) no rounding will be performed.</p><p>The <code>Vector{UInt8}</code> of labels that is returned will have length <code>floor(duration(shortest_timespan_containing(spans)), epoch)</code></p><p>The <code>encoding</code> is used to map the values in <code>stages</code> to <code>UInt8</code>s, and should be provided in the form of a <code>Dict{eltype(stages), UInt8}</code>.</p><p><code>int_encode_labels(; epoch, encoding, roundto)</code> will return a closure which captures the configuration options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L314-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.floor_containing" href="#OndaBatches.floor_containing"><code>OndaBatches.floor_containing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">floor_containing(spans; epoch)
floor_containing(; epoch)</code></pre><p>Compute the shortest timespan containing contiguous <code>spans</code>, rounded down to the nearest multiple of <code>epoch</code>.</p><p>Note that this function will not check whether spans are contiguous.</p><p>The kwarg-only method returns a closure which captures the epoch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L373-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.is_epoch_divisible" href="#OndaBatches.is_epoch_divisible"><code>OndaBatches.is_epoch_divisible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_epoch_divisible(span::TimeSpan, epoch; roundto=nothing)</code></pre><p>Tests whether <code>span</code> is evenly divisible into contiguous sub-spans of length <code>epoch</code>, after optionally rounding to <code>roundto</code> (by default, no rounding is performed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L281-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.check_epoch_divisible" href="#OndaBatches.check_epoch_divisible"><code>OndaBatches.check_epoch_divisible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_epoch_divisible(spans, epoch; roundto=Second)</code></pre><p>Throw an <code>ArgumentError</code> if any of <code>spans</code> are not evenly divisible into contiguous sub-spans of length <code>epoch</code>, according to <a href="#OndaBatches.is_epoch_divisible"><code>is_epoch_divisible</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L294-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.all_contiguous" href="#OndaBatches.all_contiguous"><code>OndaBatches.all_contiguous</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">all_contiguous(spans)</code></pre><p>Returns <code>true</code> if all <code>spans</code> are contiguous.  Assumes spans are sorted by start time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/labeled_signal.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.sample_label_span" href="#OndaBatches.sample_label_span"><code>OndaBatches.sample_label_span</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_label_span(rng, labels, label_span, labels_weight, batch_duration)</code></pre><p>Return a TimeSpan sampled from labels.  First, an epoch is sampled according to <code>labels_weight</code>.  Next, the position of this epoch in a window of <code>batch_duration</code> is sampled with uniform probability, with the constraint that the window must lie completely within <code>labels</code>.</p><p>The returned TimeSpan will have duration equal to <code>batch_duration</code> and will be relative to the start of the <em>recording</em>.  The earliest possible return span starts at <code>start(label_span)</code>, and the latest possible span stops at <code>stop(label_span)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/iterate_batch.jl#L134-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.start_batching" href="#OndaBatches.start_batching"><code>OndaBatches.start_batching</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">start_batching(channel::RemoteChannel, batches, state)</code></pre><p>Begin loading batches onto a <code>RemoteChannel</code> based on batches (e.g., <a href="#OndaBatches.RandomBatches"><code>RandomBatches</code></a>) and initial state.</p><p>This will run an infinite loop which loads one batch at a time with <a href="#OndaBatches.iterate_batch"><code>iterate_batch</code></a> and <a href="#OndaBatches.materialize_batch"><code>materialize_batch</code></a>, and <code>put!</code>s the resulting <code>(x, y)</code> and <code>state</code> values into the channel.</p><p>Batching continues until the channel is closed or an error is encountered.  When the channel is closed, the <code>InvalidStateException</code> is caught and <code>:closed</code> is returned from the function.  Other errors are rethrown.  If somehow the loop is exited without an error (honestly not sure how this would happen), <code>:done</code> is returned.</p><p>This function is intended to used with <code>@async</code> or <code>remotecall</code> (e.g., in a <a href="#OndaBatches.Batcher"><code>Batcher</code></a>); the <code>Future</code> that <code>remotecall</code> returns can be monitored with <a href="#OndaBatches.get_status"><code>get_status</code></a>.</p><p>Calls to <a href="#OndaBatches.materialize_batch"><code>materialize_batch</code></a> are wrapped in <code>Base.retry</code> to add some measure of resiliency to transient network interruptions.</p><p>Runs on the batching manager (i.e. <code>Batcher.manager</code>), but only when <code>Batcher.workers</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L5-L30">source</a></section><section><div><pre><code class="nohighlight hljs">start_batching(channel::RemoteChannel, batches, state, workers)</code></pre><p>Start batching loop, utilizing multiple workers to load batches in parallel. This method will yield batches in the same order that <code>start_batching</code> without <code>workers</code> will, using a <a href="#OndaBatches._feed_jobs!"><code>_feed_jobs!</code></a> feed batch materialization jobs to an internal channel (maintaining iteration order while distributing work across <code>workers</code>).</p><p>Runs on the batching manager (i.e. <code>Batcher.manager</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L131-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches._feed_jobs!" href="#OndaBatches._feed_jobs!"><code>OndaBatches._feed_jobs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_feed_jobs!(jobs::Channel, batches, state, workers)</code></pre><p>Function that iterates <code>batches</code> starting from <code>state</code>, creating a <code>BatchJob</code> to materialize each one using the pool of <code>workers</code>.  Each job holds is put onto the <code>jobs</code> channel in the order they were iterated, and is a struct with fields</p><ul><li><code>worker</code> PID of the worker loading this batch</li><li><code>batch_future</code> a <code>Future</code> containing the output of <code>materialize_batch</code></li><li><code>state</code> the iteration state after iterating this batch</li><li><code>prev_state</code> the iteration state before iterating this batch (i.e., the input to <code>iterate_batch(batches, state)</code> required to reproduce this batch</li></ul><p>When batch iteration is complete (as indicated by <code>iterate_batch</code> returning <code>nothing</code>, a final placeholder job will be placed on the jobs channel, with values of <code>nothing</code> everywhere except for <code>prev_state</code>, which is required to support synchronization on the client end (i.e., to confirm that the user really did ask for the final batch with <code>take!</code>).</p><p>Returns <code>nothing</code>.</p><p>Runs on the batching manager (i.e., <code>Batcher.manager</code>), in an async Task created in <code>start_batching</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/batch_services.jl#L76-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.reset!" href="#OndaBatches.reset!"><code>OndaBatches.reset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset!(pool::AbstractWorkerPool)</code></pre><p>Restore worker pool to something like the state it would be in after construction, with the channel populated with one instance of each worker managed by the pool.</p><p>This has two phases: first, the contents of the channel are cleared out to avoid double-adding workers to the channel.  Second, the contents of <code>pool.workers</code> is sorted, checked against the list of active processes with <code>procs()</code>, and then live PIDs <code>put!</code> into the pool one-by-one.  Dead workers are removed from the set of workers held by the pool.</p><p>For a <code>WorkerPool</code>, this operation is forwarded to the process holding the original pool (as with <code>put!</code>, <code>take!</code>, etc.) so it is safe to call on serialized copies of the pool.</p><p><code>nothing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/utils.jl#L89-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OndaBatches.with_channel" href="#OndaBatches.with_channel"><code>OndaBatches.with_channel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">with_channel(f, channel; closed_msg=&quot;channel close, stopping&quot;)</code></pre><p>Run <code>f(channel)</code>, handling channel closure gracefully and closing the channel if an error is caught.</p><p>If the channel is closed, the <code>InvalidStateException</code> is caught, the <code>closed_msg</code> is logged as <code>@info</code>, and <code>:closed</code> is returned.</p><p>If any other error occurs, the channel is closed before rethrowing (with a <code>@debug</code> log message reporting the error + stacktrace).</p><p>Otherwise, the return value is <code>f(channel)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/beacon-biosignals/OndaBatches.jl/blob/e8b4fe6eb62a15a5db406a5e4d5711bfb6319b1a/src/utils.jl#L53-L66">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 19 May 2023 19:37">Friday 19 May 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
