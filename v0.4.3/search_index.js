var documenterSearchIndex = {"docs":
[{"location":"","page":"Documentation","title":"Documentation","text":"CurrentModule = OndaBatches","category":"page"},{"location":"#API","page":"Documentation","title":"API","text":"","category":"section"},{"location":"#Batching-service","page":"Documentation","title":"Batching service","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Batcher\nBatcher(::Int, ::AbstractWorkerPool, ::Any; start::Any, state::Any, buffer::Any)\nBase.take!(::Batcher, state)\nstart!\nstop!\nget_status","category":"page"},{"location":"#OndaBatches.Batcher","page":"Documentation","title":"OndaBatches.Batcher","text":"A struct that provides control of batching process on one or more remote workers.  This struct keeps track of\n\nmanager::Int the PID where start_batching will be called.\nworkers an AbstractWorkerPool for the worker process(es).\nchannel::RemoteChannel the channel that batches are loaded into.\nstatus::Future the return value of the start_batching function as a Future; see get_status for a convenient accessor.\nbatches the iterator of batches that will be materialized; only requirement is that iterate_batch be defined; see RandomBatches for an example\nstate::Any batcher state (passed to iterate_batch, updated with each new batch that's yielded by the batcher.\nbuffer::Int the size of the batch buffer to keep locally (e.g., the capacity  of channel).\n\nUse start! to start the batching service, stop! to stop it, and get_status to check the status.\n\nOnce the batcher is started, the sequence of materialized batches (the output of materialize_batch) and corresponding batcher states can be retrieved by take!.\n\nArchitecture\n\nA Batcher is meant to run in an architecture where remote workers are created with a Distributed.jl cluster manager.  We use the following terminology to describe the roles these different processes play:\n\n\"Batch worker\": one or more processes that are used to actually load batches (via materialize_batch)\n\"Batch manager\": the process which coordinates the loading of batches, ensuring consistent iteration order, distributing work to the batch workers, and populating the output channel.  start_batching runs on this process.\n\"Client\": the process which is consuming batches via take!(::Batcher, state) (which OndaBatches.jl is generally agnostic about and does not manage)\n\"Manager\": the process on which the Batcher is initially created, and holds the reference for the worker pool (for multi-worker batching).\n\nnote: Note\nWe try hard to make Batchers relocatable to other processes (e.g., serializing to the Client after initialization on the Manager).  However, since a new RemoteChannel is created each time the batcher is started (including when the desired state does not match the Batcher's current state), some care needs to be taken if it matters where that channel is hosted (although this behavior may change in the future).Also note that while a running (i.e. start!ed) Batcher can be relocated to another process, the status and channel fields are not guaranteed to stay in sync on the two copies.\n\n\n\n\n\n","category":"type"},{"location":"#OndaBatches.Batcher-Tuple{Int64, Distributed.AbstractWorkerPool, Any}","page":"Documentation","title":"OndaBatches.Batcher","text":"Batcher([manager::Int,] workers::Vector{Int}, batches; start=true, state=nothing, buffer=2 * length(workers) + 1)\nBatcher(manager::Int, workers::AbstractWorkerPool, batches; start=true, state=nothing, buffer=2 * length(workers) + 1)\n\nConstruct a new Batcher, using worker IDs, batches, and initial state. The batcher's channel and status will be initialized.\n\nThe workers may be specified as an AbstractWorkerPool or a vector of PIDs (in which case a WorkerPool will be constructed).\n\nwarning: Warning\nIf workers are supplied as an AbstractWorkerPool, it is assumed that all workers managed by the pool are available for loading batches.  Whenever the batcher is stopped, the worker pool is reset, and all managed workers are returned to the channel of available workers.\n\nSee RandomBatches for an example of creation of batches.\n\nThe initial state is the state that is used by iterate_batch, e.g., the RNG used by RandomBatches.\n\nIf start=true, batching is start!ed. The state keyword argument must be supplied in this case to provide an initial state.\n\nThe buffer controls the capacity of the batch channel; a value greater than or equal to the number of workers is recommended so that batch loading workers do not block waiting for batches to be taken off the channel.\n\n\n\n\n\n","category":"method"},{"location":"#Base.take!-Tuple{Batcher, Any}","page":"Documentation","title":"Base.take!","text":"Base.take!(batcher::Batcher, state)\n\nTake one batch + state pair from the batcher, starting at the specified state. If the requested state does not match the batcher's current state, then the batching process will be restarted with the new state.  If the batcher is not running (as indicated by get_status), it will be started with start!.\n\nIf an error has occurred on any of the batch loading workers, the next call to take! will immediately throw the wrapped RemoteException, even if there are still good batches on the channel.\n\nReturns an (x, y), state tuple, where x is the batch signal data, y is the label data (see materialize_batch), and state is the next batch iterator state.\n\nRuns on the Client.\n\n\n\n\n\n","category":"method"},{"location":"#OndaBatches.start!","page":"Documentation","title":"OndaBatches.start!","text":"start!(batcher::Batcher, state)\n\nStart the remote process that loads batches into the batcher's channel.  A new channel is created since the old one cannot always be re-used.\n\nThis invokes start_batching on batcher.manager with remotecall.\n\nThe (modified) batcher is returned.\n\nIf the batcher is already running (as indicated by get_status == :running), a warning is raised and the batcher is returned.\n\nRuns on the Client.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.stop!","page":"Documentation","title":"OndaBatches.stop!","text":"stop!(batcher::Batcher)\n\nClose batcher.channel to stop the remote batching.  This blocks on fetch(batcher.status) to wait for channel closure.  If an error is thrown on the remote worker that is not caught, it will be rethrown here.\n\nThe batcher is returned.\n\nRuns on the Client.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.get_status","page":"Documentation","title":"OndaBatches.get_status","text":"get_status(batcher::Batcher)\n\nCheck the status of a remote batcher.\n\nPossible return values are\n\n:stopped: the batcher was created but not started\n:running: the batching loop is still running\n:closed: the batch channel was closed and the batch loop has terminated\n:done: the infinite loop in start_batching has terminated without  error (not expected)\na RemoteException that wraps an error thrown by start_batching on the batch manager (which may further wrap an exception thrown on a batch worker\n\n\n\n\n\n","category":"function"},{"location":"#Batch-sampling","page":"Documentation","title":"Batch sampling","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"BatchItemV2\nRandomBatches\niterate_batch_item\niterate_batch","category":"page"},{"location":"#OndaBatches.BatchItemV2","page":"Documentation","title":"OndaBatches.BatchItemV2","text":"@version BatchItemV2{T} > LabeledSignalV2 begin\n    batch_channels::T\nend\n\nLegolas record type representing a single batch item.  Fields are inherited from LabeledSignalV2 > SignalV2, and an additional batch_channels field gives a channel selector for this batch.  A \"channel selector\" is anything that can be used as a channel index for Onda.Samples, or missing (in which case, all channels will be used in the order they occur in the Samples).\n\nColumns include:\n\ncolumns from Onda.SignalV2 (everything required to Onda.load the segment)\nlabels and label_span from LabeledSignalV2\nbatch_channels\n\n\n\n\n\n","category":"type"},{"location":"#OndaBatches.RandomBatches","page":"Documentation","title":"OndaBatches.RandomBatches","text":"RandomBatches\n\nAn iterator of pseudo-randomly sampled batches derived from a table of densely labeled signals (a labeled.signal@2 table). Batches consist of batch_size \"batch items\". A single batch item consists of batch_duration * label_sample_rate labels, and batch_duration * signal_sample_rate samples of multichannel data.\n\nBatch items are sampled according to the following procedure:\n\nA single labeled signal is sampled (optionally with weights)\nA single label from that signal is sampled (optionally with weights)\nOne or more channels is selected, optionally randomly.\n\nEach batch item is sampled independently, and in particular different batch items in a given batch can have different channels included (although the same number of them, n_channels).\n\nThe functions iterate_batch_item and iterate_batch sample a single batch item and a full batch, respectively.\n\nFields\n\nlabeled_signals::DataFrame: the table of labeled signals that batches are sampled from.\nsignal_weights::AbstractWeights: weights for individual signals (unweighted by default).  May be nothing duration construction, in which case unit  weights are created.\nlabel_weights::Vector{AbstractWeights}: weights for individual labels of each labeled signal (unweighted by default).  May be nothing during construction, in which case unit weights will be created for each labeled signal.\nn_channels::Union{Nothing,Int}: the number of channels each batch item should have; this many channels are sampled without replacement, unless  n_channels === nothing in which case all channels are included.\nbatch_size::Int: the number of items that make one complete batch\nbatch_duration::TimePeriod: the duration of the window for a single batch.\n\n\n\n\n\n","category":"type"},{"location":"#OndaBatches.iterate_batch_item","page":"Documentation","title":"OndaBatches.iterate_batch_item","text":"iterate_batch_item(batches::RandomBatches, rng)\n\nYields a single \"batch item\".  See documentation for RandomBatches for the details on the sampling scheme.\n\nIndividual batch items are rows of a batch table with schema \"batch-item@2\", and are consumed by materialize_batch_item.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.iterate_batch","page":"Documentation","title":"OndaBatches.iterate_batch","text":"iterate_batch(batches::Batches, rng)\n\nReturn a \"batch listing\" that can be materialized into model training/evaluation input.\n\nA batch is a table that has one row per batch item, and follows the \"batch-item@2\" schema.\n\nThis is consumed by a materialize_batch function that can be run on a remote worker, so this sends just the minimum of information necessary to load the batch signal data, the stage labels, and the spans that say how they line up.\n\n\n\n\n\n","category":"function"},{"location":"#Batch-materialization","page":"Documentation","title":"Batch materialization","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"materialize_batch_item\nmaterialize_batch\nget_channel_data","category":"page"},{"location":"#OndaBatches.materialize_batch_item","page":"Documentation","title":"OndaBatches.materialize_batch_item","text":"materialize_batch_item(batch_item)\n\nLoad the signal data for a single BatchItemV2, selecting only the channels specified in the batch_channels field (using all channels if the field is missing).\n\nReturns a signal_data, label_data tuple, which is the contents of the data field of the signals and labels Samples objects returned by [load_labeled_signal](@ref), after the signals data by batch_channels.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.materialize_batch","page":"Documentation","title":"OndaBatches.materialize_batch","text":"materialize_batch(batch)\n\nMaterialize an entire batch, which is a table of BatchItemV2 rows.  Each row is materialized concurrently by materialize_batch_item, and the resulting signals and labels arrays are concatenated on dimension ndims(x) + 1 respectively.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.get_channel_data","page":"Documentation","title":"OndaBatches.get_channel_data","text":"get_channel_data(samples, channels)\n\nGet the data associated with the specified channels.  Default fallback simply calls samples[channels, :].data.  But custom channel selectors can be used to implement more exotic featurization schemes, (see tests for examples).\n\n\n\n\n\n","category":"function"},{"location":"#Labeled-signals","page":"Documentation","title":"Labeled signals","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"LabeledSignalV2\nsub_label_span\nlabel_signals\nload_labeled_signal\nstore_labels","category":"page"},{"location":"#OndaBatches.LabeledSignalV2","page":"Documentation","title":"OndaBatches.LabeledSignalV2","text":"@version LabeledSignalV2 > SignalV2 begin\n    label_span::TimeSpan\n    labels::Union{Samples,SignalV2}\nend\n\nLegolas.jl record type that represents one Onda signal with associated labels.  Labels must be dense and contiguous, and are represented as Onda.Samples or an Onda.Signal that refers to Onda.Samples serialized as LPCM. label_span corresponds to the time span (relative to the recording) spanned by the labels.\n\nNote that the signal span and labels' label_span are both relative to the start of the recording.\n\n\n\n\n\n","category":"type"},{"location":"#OndaBatches.sub_label_span","page":"Documentation","title":"OndaBatches.sub_label_span","text":"sub_label_span(labeled_signal, new_label_span)\n\nSelect a sub-span of labeled signals labeled_signal (with schema \"labeled.signal@2\"), returning a new labeled signal with updated labels and label_span.\n\nThe new_label_span should be relative to the start of the recording (like the signal's span and the current label_span).\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.label_signals","page":"Documentation","title":"OndaBatches.label_signals","text":"label_signals(signals, annotations; groups=:recording, kwargs...)\n\nCreate a \"labeled signals\" table from a signals table and a table of annotations containing labels.\n\nAnnotations will be passed to labels_to_samples_table and additional kwargs are forwarded there as well.  Default values there are\n\nlabels_column the column in the annotations table with labels,\nepoch the sampling period of the labels\n\nAnnotations must be\n\ncontiguous and non-overlapping (withing groups)\nregularly sampled, with spans an even integer multiple of the epoch kwarg.\n\nReturns a LabeledSignalV2 table (e.g., with schema \"labeled.signal@2\"), with labels in :labels and the signal spans occupied by these labels in :label_span.  Like the signal :span, the :label_span is relative to the start of the recording, not necessarily to the start of the data represented by the signal.\n\nIf any label span is not entirely contained within the corresponding signal span, this will throw an ArgumentError.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.load_labeled_signal","page":"Documentation","title":"OndaBatches.load_labeled_signal","text":"function load_labeled_signal(labeled_signal)\n\nLoad signal data as Onda.Samples from a labeled segment of an Onda.SignalV2 (i.e., a LabeledSignalV2 or row with schema \"labeled.signal@2\"), and returns the portion of the samples data corresponding to labeled_signal.label_span, along with the corresponding labels (as another Onda.Samples object).\n\nIf possible, this will only retrieve the bytes corresponding to labeled_signal.label_span.\n\nReturns a samples, labels tuple.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.store_labels","page":"Documentation","title":"OndaBatches.store_labels","text":"store_labels(labeled_signals, root; format=\"lpcm\")\n\nStore labels to root, replacing the Onda.Samples in the labels column of labeled_signals with Onda.Signals.\n\n\n\n\n\nstore_labels(labeled_signal::LabeledSignalV2, root; format=\"lpcm\")\n\nStore a single set of labels to root, replacing the Onda.Samples in the labels column of labeled_signals with Onda.SignalV2s.  A single updated LabeledSignalV2 row is returned.\n\nThe filepath of the stored labels' Signal is the basename of labeled_signal.file_path with \"labels_\" prepended.\n\n\n\n\n\n","category":"function"},{"location":"#Internal-utilities","page":"Documentation","title":"Internal utilities","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"warning: Warning\nNone of the following are meant to be called by users, are not part of the API for semantic versioning purposes, and can change at any time.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"labels_to_samples_table\nlabels_to_samples\nget_labels\nint_encode_labels\nfloor_containing\nis_epoch_divisible\ncheck_epoch_divisible\nall_contiguous\nsample_label_span\nstart_batching\n_feed_jobs!\nreset!\nwith_channel","category":"page"},{"location":"#OndaBatches.labels_to_samples_table","page":"Documentation","title":"OndaBatches.labels_to_samples_table","text":"labels_to_samples_table(labels::AbstractDataFrame; labels_column,\n                        groups=:recording, epoch, kwargs...)\n\nConvert annotations table into a table of labels as Samples.  This groups by groups (defaults to :recording), and then applies int_encode_labels to the labels_column and :span columns from each group, and converts the resulting UInt8 labels to Onda.Samples via labels_to_samples.  The sampling rate for the resulting labels is 1 / epoch.  The samples are returned in the :labels column.\n\nAlong with epoch, additional kwargs are forwarded to int_encode_labels:\n\nencoding::Dict the label -> UInt8 mapping to use for encoding\nroundto controls rounding of \"shaggy spans\" (defaults to nothing for no rounding)\n\nThe span corresponding to these labels is determined by floor_containing and returned in the :label_span column.\n\nA DataFrame is returned with the :labels and :label_span per group, as well as the groups variables.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.labels_to_samples","page":"Documentation","title":"OndaBatches.labels_to_samples","text":"labels_to_samples(labels::AbstractVector{UInt8}; epoch)\nlabels_to_samples(; epoch)\n\nConvert a vector of UInt8 stage labels sampled evenly at intervals of epoch into Onda.Samples with samples rate of 1/epoch.\n\nThe kwarg only form returns a closure that captures the epoch.\n\nThe returned samples have samples info:\n\nSamplesInfoV2(; sensor_type=\"label\",\n              channels=[\"label\"],\n              sample_unit=\"label\",\n              sample_resolution_in_unit=1,\n              sample_offset_in_unit=0,\n              sample_type=UInt8,\n              sample_rate=Second(1) / epoch)\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.get_labels","page":"Documentation","title":"OndaBatches.get_labels","text":"get_labels(labels::Samples, span)\nget_labels(labels::SignalV2, span)\n\nReturn labels as Samples, deserializing with Onda.load if necessary.  span is the span relative to the start of the recording that should be loaded.\n\nThis function is meant for internal use only; users should instead use load_labeled_signal and sub_label_span.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.int_encode_labels","page":"Documentation","title":"OndaBatches.int_encode_labels","text":"int_encode_labels(stages, spans; epoch, encoding::Dict,\n                  roundto=nothing)\nint_encode_labels(; epoch, encoding, roundto)\n\nReturn a Vector{UInt8} of stage labels, using encoding to look up each stage label in stages, sampled evenly at intervals of epoch.  spans are expanded into non-overlapping, contiguous spans of duration epoch; spans must be contiguous and with durations evenly divisible by epoch, except for the final span which will be truncated.  spans durations will be rounded to the nearest roundto (can be a TimePeriod subtype or instance, such as Millisecond(100), or nothing) before division into epochs to accommodate minor errors in stage label durations; if roundto=nothing (the default) no rounding will be performed.\n\nThe Vector{UInt8} of labels that is returned will have length floor(duration(shortest_timespan_containing(spans)), epoch)\n\nThe encoding is used to map the values in stages to UInt8s, and should be provided in the form of a Dict{eltype(stages), UInt8}.\n\nint_encode_labels(; epoch, encoding, roundto) will return a closure which captures the configuration options.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.floor_containing","page":"Documentation","title":"OndaBatches.floor_containing","text":"floor_containing(spans; epoch)\nfloor_containing(; epoch)\n\nCompute the shortest timespan containing contiguous spans, rounded down to the nearest multiple of epoch.\n\nNote that this function will not check whether spans are contiguous.\n\nThe kwarg-only method returns a closure which captures the epoch.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.is_epoch_divisible","page":"Documentation","title":"OndaBatches.is_epoch_divisible","text":"is_epoch_divisible(span::TimeSpan, epoch; roundto=nothing)\n\nTests whether span is evenly divisible into contiguous sub-spans of length epoch, after optionally rounding to roundto (by default, no rounding is performed).\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.check_epoch_divisible","page":"Documentation","title":"OndaBatches.check_epoch_divisible","text":"check_epoch_divisible(spans, epoch; roundto=Second)\n\nThrow an ArgumentError if any of spans are not evenly divisible into contiguous sub-spans of length epoch, according to is_epoch_divisible.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.all_contiguous","page":"Documentation","title":"OndaBatches.all_contiguous","text":"all_contiguous(spans)\n\nReturns true if all spans are contiguous.  Assumes spans are sorted by start time.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.sample_label_span","page":"Documentation","title":"OndaBatches.sample_label_span","text":"sample_label_span(rng, labels, label_span, labels_weight, batch_duration)\n\nReturn a TimeSpan sampled from labels.  First, an epoch is sampled according to labels_weight.  Next, the position of this epoch in a window of batch_duration is sampled with uniform probability, with the constraint that the window must lie completely within labels.\n\nThe returned TimeSpan will have duration equal to batch_duration and will be relative to the start of the recording.  The earliest possible return span starts at start(label_span), and the latest possible span stops at stop(label_span).\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.start_batching","page":"Documentation","title":"OndaBatches.start_batching","text":"start_batching(channel::RemoteChannel, batches, state)\n\nBegin loading batches onto a RemoteChannel based on batches (e.g., RandomBatches) and initial state.\n\nThis will run an infinite loop which loads one batch at a time with iterate_batch and materialize_batch, and put!s the resulting (x, y) and state values into the channel.\n\nBatching continues until the channel is closed or an error is encountered.  When the channel is closed, the InvalidStateException is caught and :closed is returned from the function.  Other errors are rethrown.  If somehow the loop is exited without an error (honestly not sure how this would happen), :done is returned.\n\nThis function is intended to used with @async or remotecall (e.g., in a Batcher); the Future that remotecall returns can be monitored with get_status.\n\nCalls to materialize_batch are wrapped in Base.retry to add some measure of resiliency to transient network interruptions.\n\nRuns on the batching manager (i.e. Batcher.manager), but only when Batcher.workers is empty.\n\n\n\n\n\nstart_batching(channel::RemoteChannel, batches, state, workers)\n\nStart batching loop, utilizing multiple workers to load batches in parallel. This method will yield batches in the same order that start_batching without workers will, using a _feed_jobs! feed batch materialization jobs to an internal channel (maintaining iteration order while distributing work across workers).\n\nRuns on the batching manager (i.e. Batcher.manager)\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches._feed_jobs!","page":"Documentation","title":"OndaBatches._feed_jobs!","text":"_feed_jobs!(jobs::Channel, batches, state, workers)\n\nFunction that iterates batches starting from state, creating a BatchJob to materialize each one using the pool of workers.  Each job holds is put onto the jobs channel in the order they were iterated, and is a struct with fields\n\nworker PID of the worker loading this batch\nbatch_future a Future containing the output of materialize_batch\nstate the iteration state after iterating this batch\nprev_state the iteration state before iterating this batch (i.e., the input to iterate_batch(batches, state) required to reproduce this batch\n\nWhen batch iteration is complete (as indicated by iterate_batch returning nothing, a final placeholder job will be placed on the jobs channel, with values of nothing everywhere except for prev_state, which is required to support synchronization on the client end (i.e., to confirm that the user really did ask for the final batch with take!).\n\nReturns nothing.\n\nRuns on the batching manager (i.e., Batcher.manager), in an async Task created in start_batching.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.reset!","page":"Documentation","title":"OndaBatches.reset!","text":"reset!(pool::AbstractWorkerPool)\n\nRestore worker pool to something like the state it would be in after construction, with the channel populated with one instance of each worker managed by the pool.\n\nThis has two phases: first, the contents of the channel are cleared out to avoid double-adding workers to the channel.  Second, the contents of pool.workers is sorted, checked against the list of active processes with procs(), and then live PIDs put! into the pool one-by-one.  Dead workers are removed from the set of workers held by the pool.\n\nFor a WorkerPool, this operation is forwarded to the process holding the original pool (as with put!, take!, etc.) so it is safe to call on serialized copies of the pool.\n\nnothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"#OndaBatches.with_channel","page":"Documentation","title":"OndaBatches.with_channel","text":"with_channel(f, channel; closed_msg=\"channel close, stopping\")\n\nRun f(channel), handling channel closure gracefully and closing the channel if an error is caught.\n\nIf the channel is closed, the InvalidStateException is caught, the closed_msg is logged as @info, and :closed is returned.\n\nIf any other error occurs, the channel is closed before rethrowing (with a @debug log message reporting the error + stacktrace).\n\nOtherwise, the return value is f(channel).\n\n\n\n\n\n","category":"function"}]
}
